// ---------------------------------------------------------------------------------------------------- //
// Nintendo hireme by JRios anonbeat@gmail.com
// ---------------------------------------------------------------------------------------------------- //
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h> 

typedef unsigned char u8;
typedef unsigned int u32;

// #define FORWARD_DEBUG

// ---------------------------------------------------------------------------------------------------- //
u8 confusion1[ 256 ] = {
	0xac,0xd1,0x25,0x94,0x1f,0xb3,0x33,0x28,0x7c,0x2b,0x17,0xbc,0xf6,0xb0,0x55,0x5d,
	0x8f,0xd2,0x48,0xd4,0xd3,0x78,0x62,0x1a,0x02,0xf2,0x01,0xc9,0xaa,0xf0,0x83,0x71,
	0x72,0x4b,0x6a,0xe8,0xe9,0x42,0xc0,0x53,0x63,0x66,0x13,0x4a,0xc1,0x85,0xcf,0x0c,
	0x24,0x76,0xa5,0x6e,0xd7,0xa1,0xec,0xc6,0x04,0xc2,0xa2,0x5c,0x81,0x92,0x6c,0xda,
	0xc6,0x86,0xba,0x4d,0x39,0xa0,0x0e,0x8c,0x8a,0xd0,0xfe,0x59,0x96,0x49,0xe6,0xea,
	0x69,0x30,0x52,0x1c,0xe0,0xb2,0x05,0x9b,0x10,0x03,0xa8,0x64,0x51,0x97,0x02,0x09,
	0x8e,0xad,0xf7,0x36,0x47,0xab,0xce,0x7f,0x56,0xca,0x00,0xe3,0xed,0xf1,0x38,0xd8,
	0x26,0x1c,0xdc,0x35,0x91,0x43,0x2c,0x74,0xb4,0x61,0x9d,0x5e,0xe9,0x4c,0xbf,0x77,
	0x16,0x1e,0x21,0x1d,0x2d,0xa9,0x95,0xb8,0xc3,0x8d,0xf8,0xdb,0x34,0xe1,0x84,0xd6,
	0x0b,0x23,0x4e,0xff,0x3c,0x54,0xa7,0x78,0xa4,0x89,0x33,0x6d,0xfb,0x79,0x27,0xc4,
	0xf9,0x40,0x41,0xdf,0xc5,0x82,0x93,0xdd,0xa6,0xef,0xcd,0x8d,0xa3,0xae,0x7a,0xb6,
	0x2f,0xfd,0xbd,0xe5,0x98,0x66,0xf3,0x4f,0x57,0x88,0x90,0x9c,0x0a,0x50,0xe7,0x15,
	0x7b,0x58,0xbc,0x07,0x68,0x3a,0x5f,0xee,0x32,0x9f,0xeb,0xcc,0x18,0x8b,0xe2,0x57,
	0xb7,0x49,0x37,0xde,0xf5,0x99,0x67,0x5b,0x3b,0xbb,0x3d,0xb5,0x2d,0x19,0x2e,0x0d,
	0x93,0xfc,0x7e,0x06,0x08,0xbe,0x3f,0xd9,0x2a,0x70,0x9a,0xc8,0x7d,0xd8,0x46,0x65,
	0x22,0xf4,0xb9,0xa2,0x6f,0x12,0x1b,0x14,0x45,0xc7,0x87,0x31,0x60,0x29,0xf7,0x73
};

u8 confusion2[ 256 ] = {
	0x2c,0x97,0x72,0xcd,0x89,0xa6,0x88,0x4c,0xe8,0x83,0xeb,0x59,0xca,0x50,0x3f,0x27,
	0x4e,0xae,0x43,0xd5,0x6e,0xd0,0x99,0x7b,0x7c,0x40,0x0c,0x52,0x86,0xc1,0x46,0x12,
	0x5a,0x28,0xa8,0xbb,0xcb,0xf0,0x11,0x95,0x26,0x0d,0x34,0x66,0x22,0x18,0x6f,0x51,
	0x9b,0x3b,0xda,0xec,0x5e,0x00,0x2a,0xf5,0x8f,0x61,0xba,0x96,0xb3,0xd1,0x30,0xdc,
	0x33,0x75,0xe9,0x6d,0xc8,0xa1,0x3a,0x3e,0x5f,0x9d,0xfd,0xa9,0x31,0x9f,0xaa,0x85,
	0x2f,0x92,0xaf,0x67,0x78,0xa5,0xab,0x03,0x21,0x4f,0xb9,0xad,0xfe,0xf3,0x42,0xfc,
	0x17,0xd7,0xee,0xa3,0xd8,0x80,0x14,0x2e,0xa0,0x47,0x55,0xc4,0xff,0xe5,0x13,0x3f,
	0x81,0xb6,0x7a,0x94,0xd0,0xb5,0x54,0xbf,0x91,0xa7,0x37,0xf1,0x6b,0xc9,0x1b,0xb1,
	0x3c,0xb6,0xd9,0x32,0x24,0x8d,0xf2,0x82,0xb4,0xf9,0xdb,0x7d,0x44,0xfb,0x1e,0xd4,
	0xea,0x5d,0x35,0x69,0x23,0x71,0x57,0x01,0x06,0xe4,0x55,0x9a,0xa4,0x58,0x56,0xc7,
	0x4a,0x8c,0x8a,0xd6,0x6a,0x49,0x70,0xc5,0x8e,0x0a,0x62,0xdc,0x29,0x4b,0x42,0x41,
	0xcb,0x2b,0xb7,0xce,0x08,0xa1,0x76,0x1d,0x1a,0xb8,0xe3,0xcc,0x7e,0x48,0x20,0xe6,
	0xf8,0x45,0x93,0xde,0xc3,0x63,0x0f,0xb0,0xac,0x5c,0xba,0xdf,0x07,0x77,0xe7,0x4e,
	0x1f,0x28,0x10,0x6c,0x59,0xd3,0xdd,0x2d,0x65,0x39,0xb2,0x74,0x84,0x3d,0xf4,0xbd,
	0xc7,0x79,0x60,0x0b,0x4d,0x33,0x36,0x25,0xbc,0xe0,0x09,0xcf,0x5b,0xe2,0x38,0x9e,
	0xc0,0xef,0xd2,0x16,0x05,0xbe,0x53,0xf7,0xc2,0xc6,0xa2,0x24,0x98,0x1c,0xad,0x04
};

// ---------------------------------------------------------------------------------------------------- //
struct Deconf {
	u8 count;
	u8 data[ 2 ];
};

struct Deconf deconfusion1[ 256 ];
struct Deconf deconfusion2[ 256 ];

// ---------------------------------------------------------------------------------------------------- //
u32 diffusion[ 32 ] = {
	0xf26cb481,0x16a5dc92,0x3c5ba924,0x79b65248,0x2fc64b18,0x615acd29,0xc3b59a42,0x976b2584,
	0x6cf281b4,0xa51692dc,0x5b3c24a9,0xb6794852,0xc62f184b,0x5a6129cd,0xb5c3429a,0x6b978425,
	0xb481f26c,0xdc9216a5,0xa9243c5b,0x524879b6,0x4b182fc6,0xcd29615a,0x9a42c3b5,0x2584976b,
	0x81b46cf2,0x92dca516,0x24a95b3c,0x4852b679,0x184bc62f,0x29cd5a61,0x429ab5c3,0x84256b97
};

// ---------------------------------------------------------------------------------------------------- //
u8 input[ 32 ] = {
	// //change only this :
	// 0x66,0xd5,0x4e,0x28,0x5f,0xff,0x6b,0x53,0xac,0x3b,0x34,0x14,0xb5,0x3c,0xb2,0xc6,0xa4,0x85,0x1e,0x0d,0x86,0xc7,0x4f,0xba,0x75,0x5e,0xcb,0xc3,0x6e,0x48,0x79,0x8f
	// 0x77,0x29,0xee,0x14,0x3d,0xd8,0x41,0xaa,0x27,0x6b,0x59,0x84,0xb7,0xee,0x20,0xc6,0x1b,0x30,0x44,0x33,0x27,0xb2,0xa7,0xde,0xf4,0x37,0x53,0xa6,0x8a,0xb7,0x51,0x2c
	// 0xad,0xae,0x3d,0x43,0x4b,0xaa,0x00,0x8d,0xfc,0x59,0x07,0x4c,0x91,0xa6,0xca,0xb7,0x34,0xc0,0x1e,0x72,0xf7,0xbb,0x6e,0x9b,0x05,0x9b,0x60,0x15,0xc8,0xc1,0x14,0xd8
	// 0x9a,0x35,0xdf,0x98,0xf9,0x25,0xa4,0xd0,0x69,0xe3,0x5d,0xb6,0x34,0x5a,0xf9,0x4a,0x38,0x5d,0xc2,0x35,0x60,0xf8,0x4d,0xca,0xa0,0x2c,0x35,0xe2,0x7e,0xd3,0xed,0x1b
	// 0x64,0x74,0x50,0x8a,0xce,0xc0,0x34,0xd3,0x4c,0x30,0xf9,0xe6,0xee,0x7b,0x72,0x1c,0xa9,0xc7,0xc7,0x2c,0xa8,0xd5,0xa7,0x8d,0xde,0xcc,0x56,0x76,0xc8,0x2d,0xa3,0xea
	0xb6,0xa0,0xf1,0x2b,0x09,0xb5,0xce,0x4b,0xde,0x59,0x82,0xf4,0x73,0x43,0x14,0x6e,0xd8,0x6b,0x09,0x0a,0xc4,0x96,0x05,0xda,0x05,0x81,0x7d,0x71,0x03,0xd4,0xb4,0xf2
};

// ---------------------------------------------------------------------------------------------------- //
void dump( u8 * input, int count ) 
{
	for( int i = 0; i < count; i++ )
	{
		printf( "0x%02x,", input[ i ] );
	}
	printf( "\n" );
}

// ---------------------------------------------------------------------------------------------------- //
void confuse( u8 input[ 32 ], u8 output[ 32 ] )
{	
    for( u8 j = 0; j < 32; j++ )
    {
        output[ j ] = confusion1[ input[ j ] ];
        input[ j ] = 0;
    }
}

// ---------------------------------------------------------------------------------------------------- //
void difuse( u8 input[ 32 ], u8 output[ 32 ] )
{
    for( u8 j = 0; j < 32; j++ )
    {
        for( u8 k = 0; k < 32; k++ )
        {
            input[ j ] ^= output[ k ] * ( ( diffusion[ j ] >> k ) &1 );
        }
        // printf( "difuse    : (%02i) %02x\n", j, input[ j ] );
    }
}

// ---------------------------------------------------------------------------------------------------- //
void Forward( u8 input[ 32 ], u8 output[ 32 ] )
{
    for( u32 i = 0; i < 256; i++ )
    {
		#ifdef FORWARD_DEBUG
    	printf( "==== round %u ====\n", i );
    	printf( "i  : " ); dump( input, 32 );
    	printf( "o  : " ); dump( output, 32 );
		#endif
    	confuse( input, output );
		#ifdef FORWARD_DEBUG
    	printf( "i  : " ); dump( input, 32 );
    	printf( "o  : " ); dump( output, 32 );
		#endif


    	difuse( input, output );
		#ifdef FORWARD_DEBUG
    	printf( "i* : " ); dump( input, 32 );
    	printf( "o  : " ); dump( output, 32 );
		#endif
    }

	#ifdef FORWARD_DEBUG
    printf( "pre Xor: " ); dump( input, 32 );
	#endif
    for( u8 i = 0; i < 16; i++ )
    {
		#ifdef FORWARD_DEBUG
    	printf( "i: %02x (%02x)    i + 1 : %02x (%02x)  ^%02x \n", 
    	 			input[ i * 2 ], confusion1[ input[ i * 2 ] ], 
    	 			input[ i * 2 + 1 ], confusion2[ input[ i * 2 + 1 ] ],
					confusion1[ input[ i * 2 ] ] ^ confusion2[ input[ i * 2 + 1 ] ] );
		#endif
        output[ i ] = confusion1[ input[ i * 2 ] ] ^ confusion2[ input[ i * 2 + 1 ] ];
    }
}

// ---------------------------------------------------------------------------------------------------- //
u8 bytePos( u8 data, u8 array[ 256 ] )
{	
	return ( u8 * ) memchr( array, data, 256 ) - &array[ 0 ];
}

// ---------------------------------------------------------------------------------------------------- //
void generateDeconfusion( struct Deconf deconfusion[ 256 ], u8 confusion[ 256 ] )
{
	for( u32 i = 0; i < 256; i++ )
	{
		// printf("%02x ", i );
		u8 * p = confusion;
		deconfusion[ i ].count = 0;
		deconfusion[ i ].data[ 0 ] = 0;
		deconfusion[ i ].data[ 1 ] = 0;
		do {
			p = memchr( p, i, 256 - ( p - confusion ) );
			if( p )
			{
				deconfusion[ i ].data[ deconfusion[ i ].count ] = p - confusion;
				// printf( "%02x,", deconfusion[ i ].data[ deconfusion[ i ].count ] );
				deconfusion[ i ].count++;
				p++;
			}
		} while( p );
		// printf( "\n" );
	}
}

int dodeconfusionstep( u8 input[ 32 ], u8 output[ 32 ], u32 i, u8 j );

// ---------------------------------------------------------------------------------------------------- //
int validsolution( u8 input[ 32 ] )
{
	for( u8 i = 0; i < 32; i += 2 )
	{
		if( !deconfusion1[ input[ i ] ].count )
			return 0;
		if( !deconfusion2[ input[ i + 1 ] ].count )
			return 0;
	}
	return 1;
}

// ---------------------------------------------------------------------------------------------------- //
u8 backward( u8 input[ 32 ], u32 i )
{
	u8 output[ 32 ];
	// printf( "dobackwardstep %i\n", i );
	if( i < 256 )
	{		
    	// printf( "==== round %u ====\n", i );
    	// printf( "i  : " ); dump( input, 32 );
    	// printf( "o  : " ); dump( output, 32 );
    	memset( output, 0, 32 );
		difuse( output, input );
    	// printf( "i* : " ); dump( input, 32 );
    	// printf( "o  : " ); dump( output, 32 );

    	memcpy( input, output, 32 );

	    // for( u8 j = 0; j < 32; j++ )
	    // {
	    //     //output[ j ] = bytePos( input[ j ], confusion1 );
	    //     output[ j ] = deconfusion1[ input[ j ] ].data[ 0 ];
	    //     if( deconfusion1[ input[ j ] ].count != 1 )
	    //     {
	    //     	printf( "***** warning %02x %i \n", input[ j ], deconfusion1[ input[ j ] ].count );
	    //     }
	    //     input[ j ] = 0;
	    // }
	    if( !dodeconfusionstep( input, output, i, 0 ) )
	    	return 0;

    	// printf( "i +: " ); dump( input, 32 );
    	// printf( "o +: " ); dump( output, 32 );
    	// memcpy( input, output, 32 );

	    // dobackwardstep( input, i + 1 );
	}
	else
	{
		if( validsolution( input ) )
		{
			//
			// printf( "==== round %u ====\n", i );
			// printf( "i r: " ); dump( input, 32 );
			// printf( "o r: " ); dump( output, 32 );
			printf( "Solution: " ); dump( input, 32 );
			return 1;
			// exit( 0 );
		}
	}
	return 0;
}

// ---------------------------------------------------------------------------------------------------- //
int dodeconfusionstep( u8 input[ 32 ], u8 output[ 32 ], u32 i, u8 j )
{
	u8 loutput[ 32 ];
	u8 linput[ 32];
	if( j < 32 )
	{
		if( deconfusion1[ input[ j ] ].count )
		{
			memcpy( loutput, output, 32 );
			memcpy( linput, input, 32 );
		    //output[ j ] = bytePos( input[ j ], confusion1 );
		    for( u8 l = 0; l < deconfusion1[ input[ j ] ].count; l++ )
		    {
		    	// printf( " => round %03i pos %i data %02x/%02x => %02x\n", i, j, l, deconfusion1[ input[ j ] ].count, deconfusion1[ input[ j ] ].data[ l ] );
			    loutput[ j ] = deconfusion1[ input[ j ] ].data[ l ];
			    linput[ j ] = 0;
	    		if( !dodeconfusionstep( linput, loutput, i, j + 1 ) )
	    			continue;

		    	// printf( "i %01x: ", l ); dump( linput, 32 );
		    	// printf( "o %01x: ", l ); dump( loutput, 32 );
		    }
		}
		else
		{
			// printf( "Detected bad character round %03i, pos %i (%02x)\n", i, j, input[ j ] );
			return 0;
		}
	}
	else
	{
		memcpy( input, output, 32 );		    	
		// printf( "ilr: " ); dump( linput, 32 );
		// printf( "olr: " ); dump( loutput, 32 );
		// printf( "i r: " ); dump( input, 32 );
		// printf( "o r: " ); dump( output, 32 );
    	return backward( input, i + 1 );
    }
	return 1;
}

// ---------------------------------------------------------------------------------------------------- //
void generate_input_data( u8 input[ 16 ], u8 output[ 32 ] )
{
	// printf( "input: " ); dump( input, 16 );
	// printf( "pre Xor: " ); dump( input, 32 );
    for( u8 i = 0; i < 16; i++ )
    {
		while( 1 ) 
		{
			u8 first = rand() % 256;
			// printf( "trying 1: %02x\r", first );
			if( deconfusion1[ first ].count )
			{
				output[ i * 2 ] = deconfusion1[ first ].data[ 0 ];

				u8 second = first ^ input[ i ];
				// printf( "\ntryinig 2: %02x   %02x\r", second, output[ i * 2 ] );
				if( deconfusion2[ second ].count )
				{
					output[ i * 2 + 1 ] = deconfusion2[ second ].data[ 0 ];
					break;
				}
			}
		}
    }
	// printf( "output: " ); dump( output, 32 );

    // for( u8 i = 0; i < 16; i++ )
    // {
    // 	printf( "i: %02x (%02x)    i + 1 : %02x (%02x)  ^%02x \n", 
    // 	 			output[ i * 2 ], confusion1[ output[ i * 2 ] ], 
    // 	 			output[ i * 2 + 1 ], confusion2[ output[ i * 2 + 1 ] ],
	// 				confusion1[ output[ i * 2 ] ] ^ confusion2[ output[ i * 2 + 1 ] ] );
    //     // output[ i ] = confusion1[ output[ i * 2 ] ] ^ confusion2[ output[ i * 2 + 1 ] ];
    // }
}

/*
The solutions to this challenge belong to different levels :

Level 1 : an iterative algorithm which typically takes more than a second to
find a solution (for any given output). 

Most people stop here, which is fine, but if you want to go further, there is :

Level 2 : a non-iterative algorithm which typically takes less than a
millisecond to find a solution (for any given output).

Very few people have reached this level. But if you want to beat it completely,
there's yet another castle...

Level 3 : an algorithm which can provide any of the 2^128 solutions (for any
given output).

No-one has reached this level yet !
*/
// ---------------------------------------------------------------------------------------------------- //
int main( int argc, char * argv[] )
{
    u8 target[] = "Hire me!!!!!!!!";
    u8 output[ 32 ];

    Forward( input, output );

    printf( "\n\n\ns : " ), dump( output, 32 );
    printf( "    %s\n", output ); 

	srand( time( 0 ) );
	printf( "[+] generating deconfusion1\n" );
	generateDeconfusion( deconfusion1, confusion1 );
	printf( "[+] generating deconfusion2\n" );
	generateDeconfusion( deconfusion2, confusion2 );

	do {
	  	generate_input_data( target, output );
		printf( "output: " ); dump( output, 32 );
	} while( !backward( output, 0 ) );

    return memcmp( output, target, 16 ); // => contact jobs(at)nerd.nintendo.com
}

// ---------------------------------------------------------------------------------------------------- //